import aiohttp
import asyncio
import time
from datetime import datetime, timedelta, date
from threading import Lock
from bs4 import BeautifulSoup
import requests 
import tempfile
import subprocess, sys
import random
import json
import os
import sqlite3
import hashlib
import zipfile
from PIL import Image, ImageOps, ImageDraw, ImageFont
from io import BytesIO
from urllib.parse import urljoin, urlparse, urldefrag
from telebot import TeleBot, types
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton

TH·ªúI_GIAN_CH·ªú = timedelta(seconds=300)
FREE_GI·ªöI_H·∫†N_CHIA_S·∫∫ = 400
VIP_GI·ªöI_H·∫†N_CHIA_S·∫∫ = 1000
viptime = 100
ALLOWED_GROUP_ID = -6466960858   # ID BOX
admin_diggory = "ANH ƒê·ª®C PC" # v√≠ d·ª• : ƒë·ªÉ user name admin l√† @diggory347 b·ªè d·∫•u @ ƒëi l√† ƒëc
name_bot = "ANH ƒê·ª®C PC. üñ•"
zalo = "0815689536"
web = "no"
facebook = "no"
allowed_group_id = -4269071081 # ID BOX
users_keys = {}
key = ""
freeuser = []
auto_spam_active = False
last_sms_time = {}
allowed_users = []
processes = []
ADMIN_ID =  6466960858# ID ADMIN
connection = sqlite3.connect('user_data.db')
cursor = connection.cursor()
last_command_time = {}


user_cooldowns = {}
share_count = {}
global_lock = Lock()
admin_mode = False
share_log = []
tool = 'https://www.facebook.com/anhducpcc '
BOT_LINK = ' https://www.facebook.com/anhducpcc'
TOKEN = '7307387052:AAGOtd_ul7e7fG0jnz3n95nA0MYjrs1UPik'  
bot = TeleBot(TOKEN)

ADMIN_ID = 6466960858  # id admin
admins = { 6466960858}
bot_admin_list = {}
cooldown_dict = {}
allowed_users = []
muted_users = {}

def get_time_vietnam():
    return datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
def check_command_cooldown(user_id, command, cooldown):
    current_time = time.time()
    
    if user_id in last_command_time and current_time - last_command_time[user_id].get(command, 0) < cooldown:
        remaining_time = int(cooldown - (current_time - last_command_time[user_id].get(command, 0)))
        return remaining_time
    else:
        last_command_time.setdefault(user_id, {})[command] = current_time
        return None

cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        expiration_time TEXT
    )
''') 
connection.commit()

def TimeStamp():
  now = str(date.today())
  return now


def load_users_from_database():
  cursor.execute('SELECT user_id, expiration_time FROM users')
  rows = cursor.fetchall()
  for row in rows:
    user_id = row[0]
    expiration_time = datetime.strptime(row[1], '%Y-%m-%d %H:%M:%S')
    if expiration_time > datetime.now():
      allowed_users.append(user_id)


def save_user_to_database(connection, user_id, expiration_time):
  cursor = connection.cursor()
  cursor.execute(
    '''
        INSERT OR REPLACE INTO users (user_id, expiration_time)
        VALUES (?, ?)
    ''', (user_id, expiration_time.strftime('%Y-%m-%d %H:%M:%S')))
  connection.commit()
###



###
####
start_time = time.time()

def load_allowed_users():
    try:
        with open('admin_vip.txt', 'r') as file:
            allowed_users = [int(line.strip()) for line in file]
        return set(allowed_users)
    except FileNotFoundError:
        return set()

vip_users = load_allowed_users()

async def share_post(session, token, post_id, share_number):
    headers = {
        'accept': '*/*',
        'accept-encoding': 'gzip, deflate',
        'connection': 'keep-alive',
        'content-length': '0',
        'host': 'graph.facebook.com'
    }
    try:
        url = f'https://graph.facebook.com/me/feed'
        params = {
            'link': f'https://m.facebook.com/{post_id}',
            'published': '0',
            'access_token': token
        }
        async with session.post(url, headers=headers, params=params) as response:
            res = await response.json()
            print(f"Chia s·∫ª b√†i vi·∫øt th√†nh c√¥ng: {res}")
    except Exception as e:
        print(f"L·ªói khi chia s·∫ª b√†i vi·∫øt: {e}")

async def get_facebook_post_id(session, post_url):
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, nh∆∞ Gecko) Chrome/58.0.3029.110 Safari/537.3'
        }

        async with session.get(post_url, headers=headers) as response:
            response.raise_for_status()
            text = await response.text()

        soup = BeautifulSoup(text, 'html.parser')
        meta_tag = soup.find('meta', attrs={'property': 'og:url'})

        if meta_tag and 'content' in meta_tag.attrs:
            linkpost = meta_tag['content'].split('/')[-1]
            async with session.post('https://scaninfo.vn/api/fb/getID.php?url=', data={"link": linkpost}) as get_id_response:
                get_id_post = await get_id_response.json()
                if 'success' in get_id_post:
                    post_id = get_id_post["id"]
                return post_id
        else:
            raise Exception("Kh√¥ng t√¨m th·∫•y ID b√†i vi·∫øt trong c√°c th·∫ª meta")

    except Exception as e:
        return f"L·ªói: {e}"


@bot.message_handler(commands=['time'])
def handle_time(message):
    uptime_seconds = int(time.time() - start_time)
    
    uptime_minutes, uptime_seconds = divmod(uptime_seconds, 60)
    bot.reply_to(message, f'Bot ƒë√£ ho·∫°t ƒë·ªông ƒë∆∞·ª£c: {uptime_minutes} ph√∫t, {uptime_seconds} gi√¢y')
#tiktok
def fetch_tiktok_data(url):
    api_url = f'https://scaninfo.vn/api/down/tiktok.php?url={url}'
    try:
        response = requests.get(api_url)
        response.raise_for_status()  
        data = response.json()
        return data
    except requests.exceptions.RequestException as e:
        print(f"Error fetching TikTok data: {e}")
        return None

@bot.message_handler(commands=['tiktok'])
def tiktok_command(message):
    command_parts = message.text.split(maxsplit=1)
    if len(command_parts) == 2:
        url = command_parts[1].strip()
        data = fetch_tiktok_data(url)
        
        if data and 'code' in data and data['code'] == 0:
            video_title = data['data'].get('title', 'N/A')
            video_url = data['data'].get('play', 'N/A')
            music_title = data['data']['music_info'].get('title', 'N/A')
            music_url = data['data']['music_info'].get('play', 'N/A')
            
            reply_message = f"Ti√™u ƒë·ªÅ Video: {video_title}\nƒê∆∞·ªùng d·∫´n Video: {video_url}\n\nTi√™u ƒë·ªÅ Nh·∫°c: {music_title}\nƒê∆∞·ªùng d·∫´n Nh·∫°c: {music_url}"
            bot.reply_to(message, reply_message)
        else:
            bot.reply_to(message, "Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu t·ª´ TikTok.")
    else:
        bot.reply_to(message, "H√£y cung c·∫•p m·ªôt ƒë∆∞·ªùng d·∫´n TikTok h·ª£p l·ªá.")


@bot.message_handler(commands=['tool'])
def send_tool_links(message):
    markup = types.InlineKeyboardMarkup()
    
    tool_links = [
        ("https://www.facebook.com/anhducpcc" ),
        ("https://ducthinhexe.github.io/huongdan", "Tool Golike Tiktok"),
        ("https://ducthinhexe.github.io/huongdan", "Tool G·ªôp - Source")
    ]
    
    for link, desc in tool_links:
        markup.add(types.InlineKeyboardButton(text=desc, url=link))
    
    bot.reply_to(message, "Ch·ªçn m·ªôt tool t·ª´ b√™n d∆∞·ªõi(2 c≈©ng ƒëc):", reply_markup=markup)
####
#####
video_url = 'https://v16m-default.akamaized.net/b7650db4ac7f717b7be6bd6a04777a0d/66a418a5/video/tos/useast2a/tos-useast2a-ve-0068-euttp/o4QTIgGIrNbkAPGKKLKteXyLedLE7IEgeSzeE2/?a=0&bti=OTg7QGo5QHM6OjZALTAzYCMvcCMxNDNg&ch=0&cr=0&dr=0&lr=all&cd=0%7C0%7C0%7C0&cv=1&br=2576&bt=1288&cs=0&ds=6&ft=XE5bCqT0majPD12cy-773wUOx5EcMeF~O5&mime_type=video_mp4&qs=0&rc=Mzk1OzY7PGdpZjxkOTQ3M0Bpajh1O2w5cmlzbzMzZjgzM0AuNWJgLi02NjMxLzBgXjUyYSNzNmptMmRjazFgLS1kL2Nzcw%3D%3D&vvpl=1&l=202407261543513F37EAD38E23B6263167&btag=e00088000'
@bot.message_handler(commands=['add', 'adduser'])
def add_user(message):
    admin_id = message.from_user.id
    if admin_id != ADMIN_ID:
        bot.reply_to(message, 'B·∫†N KH√îNG C√ì QUY·ªÄN S·ª¨ D·ª§NG L·ªÜNH N√ÄY')
        return

    if len(message.text.split()) == 1:
        bot.reply_to(message, 'VUI L√íNG NH·∫¨P ID NG∆Ø·ªúI D√ôNG')
        return

    user_id = int(message.text.split()[1])
    allowed_users.append(user_id)
    expiration_time = datetime.now() + timedelta(days=30)
    connection = sqlite3.connect('user_data.db')
    save_user_to_database(connection, user_id, expiration_time)
    connection.close()

    # G·ª≠i video v·ªõi ti√™u ƒë·ªÅ
    caption_text = (f'NG∆Ø·ªúI D√ôNG C√ì ID {user_id}                                ƒê√É ƒê∆Ø·ª¢C TH√äM V√ÄO DANH S√ÅCH ƒê∆Ø·ª¢C PH√âP S·ª¨ D·ª§NG L·ªÜNH /spamvip')
    bot.send_video(
        message.chat.id,
        video_url,
        caption=caption_text
    )

load_users_from_database()

def is_key_approved(chat_id, key):
    if chat_id in users_keys:
        user_key, timestamp = users_keys[chat_id]
        if user_key == key:
            current_time = datetime.datetime.now()
            if current_time - timestamp <= datetime.timedelta(hours=2):
                return True
            else:
                del users_keys[chat_id]
    return False

@bot.message_handler(commands=['share'])
def share(message):
    global bot_active, global_lock, admin_mode
    chat_id = message.chat.id
    user_id = message.from_user.id
    current_time = datetime.now()


    if not bot_active:
        msg = bot.reply_to(message, 'BOT T·∫ÆT M·ªäA R·ªíI!.')
        time.sleep(10)
        try:
            bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
        except telebot.apihelper.ApiTelegramException as e:
            print(f"Error deleting message: {e}")
        return

    if chat_id != ALLOWED_GROUP_ID:
        msg = bot.reply_to(message, 'LH ADDMIN ƒê·ªÇ BI·∫æT TH√äM TH√îNG TIN ')
        time.sleep(10)
        try:
            bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
        except telebot.apihelper.ApiTelegramException as e:
            print(f"Error deleting message: {e}")
        return
    
    if admin_mode and user_id not in admins:
        msg = bot.reply_to(message, 'Ch·∫ø ƒë·ªô admin hi·ªán ƒëang b·∫≠t, ƒë·ª£i t√≠ ƒëi.')
        time.sleep(10)
        try:
            bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
        except telebot.apihelper.ApiTelegramException as e:
            print(f"Error deleting message: {e}")
        return
    
    try:
        global_lock.acquire()  
        
        args = message.text.split()
        if user_id not in allowed_users and user_id not in freeuser:
            bot.reply_to(message, 'BOT CH·ªà HO·∫†T ƒê·ªòNG KHI MUA KEY HO·∫∂C GET KEY B·∫∞NG L·ªÜNH /laykey')
            return
        if len(args) != 3:
            msg = bot.reply_to(message, '''
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë<|> /laykey tr∆∞·ªõc khi s√†i ho·∫∑c mua
‚ïë<|> /key <key> ƒë·ªÉ nh·∫≠p key 
‚ïë<|> v√≠ d·ª• /key ABCDXYZ
‚ïë<|> /share {link_buff} {s·ªë l·∫ßn chia s·∫ª}
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê''')
            time.sleep(10)
            try:
                bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
            except telebot.apihelper.ApiTelegramException as e:
                print(f"Error deleting message: {e}")
            return

        post_id, total_shares = args[1], int(args[2])

        # Ki·ªÉm tra ng∆∞·ªùi d√πng VIP ho·∫∑c Free
        if user_id in allowed_users:
            handle_vip_user(message, user_id, post_id, total_shares, current_time)
        elif user_id in freeuser:
            handle_free_user(message, user_id, post_id, total_shares, current_time)
            
    except Exception as e:
        msg = bot.reply_to(message, f'L·ªói: {e}')
        time.sleep(10)
        try:
            bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
        except telebot.apihelper.ApiTelegramException as e:
            print(f"Error deleting message: {e}")

    finally:
        if global_lock.locked():
            global_lock.release()  

def handle_vip_user(message, user_id, post_id, total_shares, current_time):
    if user_id in user_cooldowns:
        last_share_time = user_cooldowns[user_id]
        if current_time < last_share_time + timedelta(seconds=viptime):
            remaining_time = (last_share_time + timedelta(seconds=viptime) - current_time).seconds
            msg = bot.reply_to(message, f'B·∫°n c·∫ßn ƒë·ª£i {remaining_time} gi√¢y tr∆∞·ªõc khi chia s·∫ª l·∫ßn ti·∫øp theo.\nvip Delay')
            time.sleep(10)
            bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
            return
    if total_shares > VIP_GI·ªöI_H·∫†N_CHIA_S·∫∫:
        msg = bot.reply_to(message, f'S·ªë l·∫ßn chia s·∫ª v∆∞·ª£t qu√° gi·ªõi h·∫°n {VIP_GI·ªöI_H·∫†N_CHIA_S·∫∫} l·∫ßn.')
        time.sleep(10)
        bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
        return
     #ph√¢n file token kh√°c nhau
    file_path = 'token.txt'
    with open(file_path, 'r') as file:
        tokens = file.read().split('\n')

    total_live = len(tokens)

    sent_msg = bot.reply_to(message,
        f'Bot Chia S·∫ª B√†i Vi·∫øt\n\n'
        f'‚ïëS·ªë L·∫ßn Chia S·∫ª: {total_shares}\n'
        f'‚ïëFree Max 400 Share\n'
        f'‚ïë{message.from_user.username} ƒêang D√πng Vip',
        parse_mode='HTML'
    )

    bot.delete_message(chat_id=message.chat.id, message_id=message.message_id)
#check live token
    if total_live == 0:
        bot.edit_message_text(chat_id=message.chat.id, message_id=sent_msg.message_id, text='Kh√¥ng c√≥ token n√†o ho·∫°t ƒë·ªông.')
        return

    share_log.append({
        'username': message.from_user.username,
        'user_id': user_id,
        'time': current_time.strftime('%Y-%m-%d %H:%M:%S'),
        'post_id': post_id,
        'total_shares': total_shares
    })

    async def share_with_delay(session, token, post_id, count):
        await share_post(session, token, post_id, count)
        await asyncio.sleep(1)

    async def main():
        async with aiohttp.ClientSession() as session:
            tasks = []
            for i in range(total_shares):
                token = random.choice(tokens)
                share_number = share_count.get(user_id, 0) + 1
                share_count[user_id] = share_number
                tasks.append(share_with_delay(session, token, post_id, share_number))
            await asyncio.gather(*tasks)

    asyncio.run(main())

    bot.edit_message_text(chat_id=message.chat.id, message_id=sent_msg.message_id, text='ƒê∆°n c·ªßa b·∫°n ƒë√£ ho√†n th√†nh')

def handle_free_user(message, user_id, post_id, total_shares, current_time):
    if user_id in user_cooldowns:
        last_share_time = user_cooldowns[user_id]
        if current_time < last_share_time + TH·ªúI_GIAN_CH·ªú:
            remaining_time = (last_share_time + TH·ªúI_GIAN_CH·ªú - current_time).seconds
            msg = bot.reply_to(message, f'B·∫°n c·∫ßn ƒë·ª£i {remaining_time} gi√¢y tr∆∞·ªõc khi chia s·∫ª l·∫ßn ti·∫øp theo.')
            time.sleep(10)
            bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
            return

    if total_shares > FREE_GI·ªöI_H·∫†N_CHIA_S·∫∫:
        msg = bot.reply_to(message, f'S·ªë l·∫ßn chia s·∫ª v∆∞·ª£t qu√° gi·ªõi h·∫°n {FREE_GI·ªöI_H·∫†N_CHIA_S·∫∫} l·∫ßn.')
        time.sleep(10)
        bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
        return
    #token free
    file_path = 'token.txt'
    with open(file_path, 'r') as file:
        tokens = file.read().split('\n')

    total_live = len(tokens)

    sent_msg = bot.reply_to(message,
        f'Bot Chia S·∫ª B√†i Vi·∫øt\n\n'
        f'‚ïëS·ªë l·∫ßn share: {total_shares}\n'
        f'‚ïëVip Max 1000 Share\n'
        f'‚ïë{message.from_user.username} ƒêang Share Free',
        parse_mode='HTML'
    )

    bot.delete_message(chat_id=message.chat.id, message_id=message.message_id)

    if total_live == 0:
        bot.edit_message_text(chat_id=message.chat.id, message_id=sent_msg.message_id, text='Kh√¥ng c√≥ token n√†o ho·∫°t ƒë·ªông.')
        return

    share_log.append({
        'username': message.from_user.username,
        'user_id': user_id,
        'time': current_time.strftime('%Y-%m-%d %H:%M:%S'),
        'post_id': post_id,
        'total_shares': total_shares
    })

    async def share_with_delay(session, token, post_id, count):
        await share_post(session, token, post_id, count)
        await asyncio.sleep(1)

    async def main():
        async with aiohttp.ClientSession() as session:
            tasks = []
            for i in range(total_shares):
                token = random.choice(tokens)
                share_number = share_count.get(user_id, 0) + 1
                share_count[user_id] = share_number
                tasks.append(share_with_delay(session, token, post_id, share_number))
            await asyncio.gather(*tasks)

    asyncio.run(main())

    user_cooldowns[user_id] = current_time

    bot.edit_message_text(chat_id=message.chat.id, message_id=sent_msg.message_id, text='ƒê∆°n c·ªßa b·∫°n ƒë√£ ho√†n th√†nh')
@bot.message_handler(commands=['vip'])
def handle_vip(message):
    chat_id = message.chat.id
    if message.from_user.id not in vip_users:
        bot.reply_to(message, "M√ÄY KO  PH·∫¢I TH√ÄNH VI√äN VIP")
        return

   


@bot.message_handler(commands=['ls'])
def sharelog(message):
    if message.from_user.id in admins:
        if not share_log:
            bot.reply_to(message, 'ƒê√âO AI D√ôNG:))')
            return
        
        log_text = "DANH S√ÅCH NG∆Ø·ªúI D√ôNG L·ªÜNH SHARE \n"
        for log in share_log:
            log_text += f"<blockquote>L·ªãch_S·ª≠\n- User: {log['username']} (ID: {log['user_id']})\n- v√†o l√∫c {log['time']}\n- Post LINK: <a href='{log['post_id']}'>link</a>\n- S·ªë l·∫ßn chia s·∫ª: {log['total_shares']}\n</blockquote>"
        
        bot.reply_to(message, log_text, parse_mode='HTML')
    else:
        bot.reply_to(message, 'TAO ADMIN M·ªöI XEM DC')
@bot.message_handler(commands=['admod'])
def handle_on(message):
    global admin_mode
    if message.from_user.id in admins:
        admin_mode = True
        bot.reply_to(message, "CH·∫æ ƒê·ªò ADMIN ON.")
    else:
        bot.reply_to(message, "C√ì C√ÅI L√íN D√ôNG DC NH√â")

@bot.message_handler(commands=['laykey'])
def laykey(message):
    bot.reply_to(message, text='VUI L√íNG ƒê·ª¢I TRONG GI√ÇY L√ÅT!')

    with open('key.txt', 'a') as f:
        f.close()

    user_id = message.from_user.id  
    string = f'GL-{user_id}+{TimeStamp()}'  
    hash_object = hashlib.md5(string.encode())
    key = str(hash_object.hexdigest())[:10]
    print(key)
    
    url_key = requests.get(f'https://link4m.co/api-shorten/v2?api=67e6bf7c10106250256cb43f&url=http://keyvipfree.byethost4.com/?r={key}').json()['shortenedUrl']
    
    text = f'''
- KEY C·ª¶A B·∫†N {get_time_vietnam()}
- D√ôNG L·ªÜNH /key {{key}} ƒê·ªÇ TI·∫æP T·ª§C -
 [L∆ØU √ù KEY S·∫º RESET SAU 1 NG√ÄY KEY CHO 1 NG∆Ø·ªúI]
    '''

    keyboard = InlineKeyboardMarkup()
    url_button = InlineKeyboardButton(text="Get Key", url=url_key)
    admin_button = InlineKeyboardButton(text="FACEBOOK", url="https://www.facebook.com/anhducpcc")
    keyboard.add(url_button, admin_button)
    
    bot.reply_to(message, text, reply_markup=keyboard)
    
    admin_message = f"Key C·ªßa {user_id}: {key}\n b·∫°n c√≥ th·ªÉ ƒë∆∞a key n√†y cho id ng∆∞·ªùi nh·∫≠n"
    bot.send_message(ADMIN_ID, admin_message)

@bot.message_handler(commands=['key'])
def key(message):
    if len(message.text.split()) == 1:
        bot.reply_to(message, 'ƒê·ªäT C·ª§ CH∆ØA NH·∫¨P KEY')
        return

    user_id = message.from_user.id
    
    key = message.text.split()[1]
    string = f'GL-{user_id}+{TimeStamp()}'  
    hash_object = hashlib.md5(string.encode())
    expected_key = str(hash_object.hexdigest())[:10]
    if key == expected_key:
        freeuser.append(user_id)
        bot.reply_to(message, 'KEY ƒê√öNG B·∫†N C√ì TH·ªÇ TI·∫æP T·ª§C S·ª¨ D·ª§NG L·ªÜNH')
    else:
        bot.reply_to(message, 'KEY SAI R GET L·∫†I TH·ª¨ XEM HO·∫∂C IB CHO ADMIN')


@bot.message_handler(commands=['unadmod'])
def handle_off(message):
    global admin_mode
    if message.from_user.id in admins:
        admin_mode = False
        bot.reply_to(message, "Ch·∫ø ƒë·ªô admin ƒë√£ t·∫Øt.")
    else:
        bot.reply_to(message, "ADMIN L√Ä TAO OK")
@bot.message_handler(commands=['OFF'])
def bot_off(message):
    global bot_active
    if message.from_user.id in admins:
        bot_active = False
        bot.reply_to(message, 'BOT ƒê√É T·∫ÆT.')
    else:
        bot.reply_to(message, 'C√ì C√ÅI L√íN D√ôNG DC NH√â')
@bot.message_handler(commands=['ON'])
def bot_on(message):
    global bot_active
    if message.from_user.id in admins:
        bot_active = True
        bot.reply_to(message, 'BOT ƒê√É B·∫¨T.')
    else:
        bot.reply_to(message, 'C√ì C√ÅI L√íN D√ôNG DC NH√â.')
@bot.message_handler(commands=['code'])
def handle_code_command(message):
    # T√°ch l·ªánh v√† URL t·ª´ tin nh·∫Øn
    command_args = message.text.split(maxsplit=1)

    # Ki·ªÉm tra xem URL c√≥ ƒë∆∞·ª£c cung c·∫•p kh√¥ng
    if len(command_args) < 2:
        bot.reply_to(message, "Vui l√≤ng cung c·∫•p url sau l·ªánh /code. V√≠ d·ª•: /code https://xnxx.com")
        return

    url = command_args[1]
    domain = urlparse(url).netloc
    file_name = f"{domain}.txt"
    
    try:
        # L·∫•y n·ªôi dung HTML t·ª´ URL
        response = requests.get(url)
        response.raise_for_status()  # X·∫£y ra l·ªói n·∫øu c√≥ l·ªói HTTP

        # L∆∞u n·ªôi dung HTML v√†o file
        with open(file_name, 'w', encoding='utf-8') as file:
            file.write(response.text)

        # G·ª≠i file v·ªÅ ng∆∞·ªùi d√πng
        with open(file_name, 'rb') as file:
            bot.send_document(message.chat.id, file, caption=f"HTML c·ªßa trang web {url}")

        # Ph·∫£n h·ªìi tin nh·∫Øn g·ªëc
        bot.reply_to(message, "ƒê√£ g·ª≠i m√£ ngu·ªìn HTML c·ªßa trang web cho b·∫°n.")

    except requests.RequestException as e:
        bot.reply_to(message, f"ƒê√£ x·∫£y ra l·ªói khi t·∫£i trang web: {e}")

    finally:
        # ƒê·∫£m b·∫£o x√≥a file sau khi g·ª≠i
        if os.path.exists(file_name):
            try:
                os.remove(file_name)
            except Exception as e:
                bot.reply_to(message, f"ƒê√£ x·∫£y ra l·ªói khi x√≥a file: {e}")
@bot.message_handler(commands=['help', 'start'])
def send_welcome(message):
   
   
    username = message.from_user.username
    bot.reply_to(message, f'''
‚îå‚îÄ‚îÄ‚îÄ‚≠ì {name_bot}
‚îÇ¬ª Xin ch√†o @{username}
‚îÇ¬ª /help : L·ªÜNH TR·ª¢ GI√öP
‚îÇ¬ª /admin : TH√îNG TIN ADMIN
‚îÇ¬ª /spam : T·∫§N C√îNG SMS FREE
‚îÇ¬ª /spamvip : Spam SMS VIP LI√äN H·ªÜ ADMIN ƒê·ªÇ MUA 10K/TH√ÅNG
‚îÇ¬ª /share : NH·∫¨N FREE VIP
‚îÇ¬ª /laykey :L·∫§Y KEY VIP FREE
‚îÇ¬ª /KEY NH·∫¨P KEY VIP FREE
‚îÇ¬ª /id : L·∫§Y ID TELE C·ª¶A ACC
‚îÇ¬ª /tiktok : CHECK TH√îNG TIN T·∫¢I VIDEO TOPTOP
‚îÇ¬ª /time : TH·ªúI GIAN HO·∫†T ƒê·ªòNG
‚îÇ¬ª /ad : TH√äM ADMIN
‚îÇ¬ª /code : L·∫§Y CODE HTML C·ª¶A WEP
‚îÇ¬ª /tv : ƒê·ªîI NG√îN NG·ªÆ SANG TI·∫æNG VI·ªÜT 
‚îÇ¬ª L·ªÜNH ADMIN
‚îÇ¬ª /restart : KH·ªûI ƒê·ªòNG L·∫†I BOT
‚îÇ¬ª /add : TH√äM NG∆Ø·ªúI D√ôNG VIP/spamvip
‚îÇ¬ª /ON : B·∫¨T BOT‚öôÔ∏è 
‚îÇ¬ª /OFF : T·∫ÆT BOT ‚öôÔ∏è
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ßï
    ''')
@bot.message_handler(commands=['admin'])
def diggory(message):
     
    username = message.from_user.username
    diggory_chat = f'''
‚îå‚îÄ‚îÄ‚îÄ‚≠ì {name_bot}
‚îÇ¬ª Xin ch√†o @{username}
‚îÇ¬ª Bot Spam :ANHDUCPCP
‚îÇ¬ª Zalo: {zalo}
‚îÇ¬ª Website: {web}
‚îÇ¬ª Telegram: @{admin_diggory}
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    '''
    bot.send_message(message.chat.id, diggory_chat)


last_usage = {}

@bot.message_handler(commands=['spam'])
def spam(message):
    user_id = message.from_user.id
    current_time = time.time()
    if not bot_active:
        msg = bot.reply_to(message, 'Bot hi·ªán ƒëang t·∫Øt.')
        time.sleep(10)
        try:
            bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
        except telebot.apihelper.ApiTelegramException as e:
            print(f"Error deleting message: {e}")
        return
    if admin_mode and user_id not in admins:
        msg = bot.reply_to(message, 'c√≥ l·∫Ω admin ƒëang fix g√¨ ƒë√≥ h√£y ƒë·ª£i x√≠u')
    if user_id in last_usage and current_time - last_usage[user_id] < 100:
        bot.reply_to(message, f"CH·ªú CH√öT X√çU SƒêT V·∫™N ƒêANG B·ªä T·∫§N C√îNG {100 - (current_time - last_usage[user_id]):.1f} CH·ªú X√çU.")
        return

    last_usage[user_id] = current_time

    # Ph√¢n t√≠ch c√∫ ph√°p l·ªánh
    params = message.text.split()[1:]
    if len(params) != 2:
        bot.reply_to(message, "/spam VD_SƒêT_ 012345678 9  TRONG ƒê√ì 9 L√Ä S·ªê L·∫¶N SPAM ")
        return

    sdt, count = params

    if not count.isdigit():
        bot.reply_to(message, "S·ªë l·∫ßn spam kh√¥ng h·ª£p l·ªá. Vui l√≤ng ch·ªâ nh·∫≠p s·ªë.")
        return

    count = int(count)

    if count > 5:
        bot.reply_to(message, "/spam sdt s·ªë_l·∫ßn t·ªëi ƒëa l√† 5 - ƒë·ª£i 100gi√¢y s·ª≠ d·ª•ng l·∫°i.")
        return

    if sdt in blacklist:
        bot.reply_to(message, f"S·ªë ƒëi·ªán tho·∫°i {sdt} ƒë√£ b·ªã c·∫•m spam.")
        return

    diggory_chat3 = f'''
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠ì {name_bot}
‚îÇ SPAM: TH√ÄNH C√îNG
‚îÇ S·ªê L·∫¶N T·∫§N C√îNG FREE: {count}
‚îÇƒêANG T·∫§N C√îNG : {sdt}
‚îÇ T·∫§N C√îNG FREE 5-10P 
‚îÇ SPAM V·ª™A PH·∫¢I ƒê·ªÇ ·ªîN ƒê·ªäNH BOT NH√â  
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    '''

    script_filename = "dec.py"  # T√™n file Python trong c√πng th∆∞ m·ª•c
    try:
        # Ki·ªÉm tra xem file c√≥ t·ªìn t·∫°i kh√¥ng
        if not os.path.isfile(script_filename):
            bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y file script. Vui l√≤ng ki·ªÉm tra l·∫°i.")
            return

        # ƒê·ªçc n·ªôi dung file v·ªõi m√£ h√≥a utf-8
        with open(script_filename, 'r', encoding='utf-8') as file:
            script_content = file.read()

        # T·∫°o file t·∫°m th·ªùi
        with tempfile.NamedTemporaryFile(delete=False, suffix=".py") as temp_file:
            temp_file.write(script_content.encode('utf-8'))
            temp_file_path = temp_file.name

        # Ch·∫°y file t·∫°m th·ªùi
        process = subprocess.Popen(["python", temp_file_path, sdt, str(count)])
        bot.send_message(message.chat.id, diggory_chat3)
    except FileNotFoundError:
        bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y file.")
    except Exception as e:
        bot.reply_to(message, f"L·ªói x·∫£y ra: {str(e)}")



blacklist = ["112", "113", "114", "115", "116", "117", "118", "119", "0", "1", "2", "3", "4"]


# X·ª≠ l√Ω l·ªánh /spamvip
@bot.message_handler(commands=['spamvip'])
def supersms(message):
    user_id = message.from_user.id
    if user_id not in allowed_users:
        bot.reply_to(message, 'H√ÉY LI√äN H·ªÜ ADMIN ƒê·ªÇ TH√äM VIPH√£y Mua Vip ƒê·ªÉ S·ª≠ D·ª•ng.')
        return
    
    current_time = time.time()
    if user_id in last_usage and current_time - last_usage[user_id] < 1:
        bot.reply_to(message, f"CH·ªú CH√öT X√çU SƒêT V·∫™N ƒêANG B·ªä T·∫§N C√îNG{250 - (current_time - last_usage[user_id]):.1f} CH·ªú X√çU")
        return
    
    last_usage[user_id] = current_time

    params = message.text.split()[1:]

    if len(params) != 2:
        bot.reply_to(message, "/spamvip VD_SƒêT 012345678 9 TRONG ƒê√ì 9 L√Ä S·ªê L·∫¶N SPAM ")
        return

    sdt, count = params

    if not count.isdigit():
        bot.reply_to(message, "L·ªñI S·ªê L·∫¶N SPAM CH·ªà T·ª™ 1_9")
        return
    
    count = int(count)
    
    if count > 30:
        bot.reply_to(message, "/spamvip sdt 30 th√¥i nh√© - ƒë·ª£i 250gi√¢y s·ª≠ d·ª•ng l·∫°i.")
        return

    if sdt in blacklist:
        bot.reply_to(message, f"S·ªë ƒëi·ªán tho·∫°i {sdt} ƒë√£ b·ªã c·∫•m spam.")
        return

    diggory_chat3 = f'''
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠ì {name_bot}
‚îÇ T·∫§N C√îNG: TH√ÄNH C√îNG
‚îÇS·ªê L·∫¶N T·∫§N C√îNG VIP: {count}
‚îÇ ƒêANG T·∫§N C√îNG : {sdt}
‚îÇ T·∫§N C√îNG VIP S·∫º L√ÇU H∆†N NH√â
‚îÇ SPAM V·ª™A PH·∫¢I TH√îI NH√â !  
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    '''

    script_filename = "dec.py"  # T√™n file Python trong c√πng th∆∞ m·ª•c
    try:
        if os.path.isfile(script_filename):
            with open(script_filename, 'r', encoding='utf-8') as file:
                script_content = file.read()

            with tempfile.NamedTemporaryFile(delete=False, suffix=".py") as temp_file:
                temp_file.write(script_content.encode('utf-8'))
                temp_file_path = temp_file.name

            process = subprocess.Popen(["python", temp_file_path, sdt, str(count)])
            bot.send_message(message.chat.id, diggory_chat3)
        else:
            bot.reply_to(message, "T·∫≠p tin kh√¥ng t√¨m th·∫•y.")
    except Exception as e:
        bot.reply_to(message, f"L·ªói x·∫£y ra: {str(e)}")

# X·ª≠ l√Ω l·ªánh /voice
API_URL = "https://scaninfo.vn/api/gg/voice.php?text={}"

@bot.message_handler(commands=['voice'])
def handle_voice_command(message):
    text = message.text.split('/voice ', 1)[1].strip()
    api_request_url = API_URL
    response = requests.post(api_request_url, data={'text': text})
    if response.status_code == 200:
        audio_data = response.content
        if audio_data:
            bot.send_voice(message.chat.id, audio_data, caption=f"N·ªôi dung: {text}", reply_to_message_id=message.message_id)
        else:
            bot.reply_to(message, f"@{message.from_user.username} Kh√¥ng th·ªÉ t·∫°o gi·ªçng n√≥i t·ª´ vƒÉn b·∫£n n√†y.")
    else:
        bot.reply_to(message, f"@{message.from_user.username} ƒê√£ x·∫£y ra l·ªói khi chuy·ªÉn ƒë·ªïi vƒÉn b·∫£n th√†nh gi·ªçng n√≥i.")

ADMIN_NAME = "ANHDUCPC"

@bot.message_handler(commands=['ad'])
def send_admin_info(message):
    bot.send_message(
        message.chat.id, 
        f"LH ADDMIN ƒê·ªÇ BI·∫æT TH√îNG TIN=> : {ADMIN_NAME}\nID: `{ADMIN_ID}`", 
        parse_mode='Markdown'
    )

@bot.message_handler(func=lambda message: message.text.isdigit())
def copy_user_id(message):
    bot.send_message(message.chat.id, f"ID c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c sao ch√©p: `{message.text}`", parse_mode='Markdown')
ADMIN_NAME = "ANHDUCPC"
@bot.message_handler(commands=['id'])
def get_user_id(message):
    if len(message.text.split()) == 1:  
        user_id = message.from_user.id
        bot.reply_to(message, f"ID c·ªßa b·∫°n l√†: `{user_id}`", parse_mode='Markdown')
    else:  
        username = message.text.split('@')[-1].strip()
        try:
            user = bot.get_chat(username)  # L·∫•y th√¥ng tin ng∆∞·ªùi d√πng t·ª´ username
            bot.reply_to(message, f"ID c·ªßa {user.first_name} l√†: `{user.id}`", parse_mode='Markdown')
        except Exception as e:
            bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng c√≥ username n√†y.")
@bot.message_handler(commands=['ID'])
def handle_id_command(message):
    chat_id = message.chat.id
    bot.reply_to(message, f"ID c·ªßa nh√≥m n√†y l√†: {chat_id}")
####################
import time

def restart_program():
    """Kh·ªüi ƒë·ªông l·∫°i script ch√≠nh v√† m√¥i tr∆∞·ªùng ch·∫°y."""
    python = sys.executable
    script = sys.argv[0]
    # Kh·ªüi ƒë·ªông l·∫°i script ch√≠nh t·ª´ ƒë·∫ßu
    try:
        subprocess.Popen([python, script])
    except Exception as e:
        print(f"Kh·ªüi ƒë·ªông l·∫°i kh√¥ng th√†nh c√¥ng: {e}")
    finally:
        time.sleep(10)  # ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ ƒë·∫£m b·∫£o instance c≈© ƒë√£ ng·ª´ng ho√†n to√†n
        sys.exit()

@bot.message_handler(commands=['restart'])
def handle_reset(message):
    if message.from_user.id == ADMIN_ID:
        bot.reply_to(message, "BOT ƒêANG KH·ªúI ƒê·ªòNG L·∫†I...")
        restart_program()
    else:
        bot.reply_to(message, "B·∫†N KO C√ì QUY·ªÄN D√ôNG L·ªÜNH N√ÄY !")
####
@bot.message_handler(commands=['tv'])
def tieng_viet(message):
    chat_id = message.chat.id
    message_id = message.message_id
    
    keyboard = types.InlineKeyboardMarkup()
    url_button = types.InlineKeyboardButton("Ti·∫øng Vi·ªát üáªüá≥", url='https://t.me/setlanguage/abcxyz')
    keyboard.add(url_button)
    
    bot.send_message(chat_id, 'Click V√†o N√∫t "<b>Ti·∫øng Vi·ªát</b>" ƒë·ªÉ ƒë·ªïi th√†nh tv VN in ƒë·ªù b√©t.', reply_markup=keyboard, parse_mode='HTML')
    
    # Delete user's command message
    try:
        bot.delete_message(chat_id, message_id)
    except Exception as e:
        bot.send_message(chat_id, f"Kh√¥ng th·ªÉ x√≥a tin nh·∫Øn: {e}", parse_mode='HTML')

############
if __name__ == "__main__":
    bot_active = True
    bot.infinity_polling()